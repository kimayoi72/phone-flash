{"version":3,"sources":["logo.svg","components/atoms/Permission.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","PermissionContext","React","createContext","state","name","PermissionSwitch","props","permission","permissionDescription","useState","setState","navigator","permissions","query","then","result","onchange","usePermissionState","Provider","value","children","PermissionWhen","useContext","AudioPage","audioCtx","useMemo","window","AudioContext","source","setSource","analyzer","setAnalyzer","useEffect","mediaDevices","getUserMedia","audio","stream","createMediaStreamSource","analyzerNode","createAnalyser","fftSize","smoothingTimeConstant","minDecibels","maxDecibels","gainNode","createGain","gain","setValueAtTime","currentTime","connect","useMediaStream","canvasRef","useRef","canvasCtx","current","getContext","resume","undefined","canvas","width","height","draw","dataArray","clearRect","fillStyle","fillRect","Uint8Array","frequencyBinCount","getByteTimeDomainData","lineWidth","strokeStyle","beginPath","sliceWidth","length","x","i","y","moveTo","lineTo","stroke","drawTimeData","getByteFrequencyData","barWidth","h","requestAnimationFrame","ref","style","display","App","className","src","logo","alt","config","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","onUpdate","onSuccess","catch","error","ReactDOM","render","document","getElementById","URL","process","href","origin","addEventListener","fetch","response","contentType","headers","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.ff77b7d4.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.348672aa.svg\";","import { useState, Fragment, useContext } from \"react\"\nimport React from \"react\"\n\n/**\n * Checks given permission\n * @export\n * @param {PermissionDescriptor} permissionDescription\n * @returns {PermissionState}\n */\nexport function usePermissionState(permissionDescription: PermissionDescriptor): PermissionState {\n  const [state, setState] = useState<PermissionState>(() => \"denied\");\n  navigator.permissions.query(permissionDescription).then(result => {\n    setState(result.state);\n    result.onchange = () => setState(result.state);\n  });\n  return state;\n}\n\n\ninterface PermissionContextType {\n  state : PermissionState\n  name : PermissionName\n}\nconst permissionContext : PermissionContextType = {\n  state : 'denied',\n  name : 'microphone'\n}\nconst PermissionContext = React.createContext<PermissionContextType>(permissionContext)\ninterface PermissionSwitchProps {\n  permissionDescription : PermissionDescriptor\n}\nexport const PermissionSwitch: React.SFC<PermissionSwitchProps> = (props) => {\n  const permission = usePermissionState(props.permissionDescription)\n  return (\n    <PermissionContext.Provider value={{state:permission, name:props.permissionDescription.name}}>\n      {props.children}\n    </PermissionContext.Provider>\n  )\n}\n\ninterface PermissionWhenProps {\n  state : PermissionState\n}\nexport const PermissionWhen: React.SFC<PermissionWhenProps> = (props) => {\n  const permission = useContext(PermissionContext)\n  if (permission.state === props.state) {\n    return (<Fragment>{props.children}</Fragment>)\n  }\n  return (null)\n}\n","import React, {\n  useState,\n  useCallback,\n  useEffect,\n  ChangeEventHandler,\n  Fragment,\n  useMemo,\n  useRef\n} from \"react\";\nimport {\n  PermissionSwitch,\n  PermissionWhen\n} from \"./components/atoms/Permission\";\n\nimport logo from \"./logo.svg\";\nimport \"./App.css\";\n\nimport * as config from \"./../package.json\";\n\ntype MediaInfoFilter = (value: MediaDeviceInfo) => boolean;\n\nfunction useMediaDevices(\n  withRequestAccess: boolean,\n  deviceFilter?: MediaInfoFilter\n) {\n  const [devices, setDevices] = useState<MediaDeviceInfo[]>([]);\n\n  const enumerateDevices = useCallback(\n    () =>\n      navigator.mediaDevices\n        .enumerateDevices()\n        .then(devices =>\n          setDevices(deviceFilter ? devices.filter(deviceFilter) : devices)\n        ),\n    [deviceFilter]\n  );\n\n  useEffect(() => {\n    if (withRequestAccess) {\n      navigator.mediaDevices\n        .getUserMedia({ audio: true })\n        .then(stream => enumerateDevices());\n    } else {\n      enumerateDevices();\n    }\n  }, [withRequestAccess, enumerateDevices]);\n\n  return devices;\n}\n\ntype OnDeviceSelectedCallback = (\n  deviceInfo: MediaDeviceInfo | undefined\n) => void;\ninterface MediaDeviceSelectorProps {\n  onSelected: OnDeviceSelectedCallback;\n  constraints?: MediaStreamConstraints;\n}\nexport const MediaDeviceSelector: React.SFC<\n  MediaDeviceSelectorProps\n> = props => {\n  const defaultDeviceFilter = (t: MediaDeviceInfo) => t.kind === \"audioinput\";\n  const devices = useMediaDevices(true, defaultDeviceFilter);\n  const handleOnChange = useCallback<ChangeEventHandler<HTMLSelectElement>>(\n    event => {\n      event.preventDefault();\n      if (props.onSelected) {\n        props.onSelected(devices[event.target.selectedIndex]);\n      }\n    },\n    [devices, props]\n  );\n  return (\n    <select onChange={handleOnChange}>\n      {devices.map(info => {\n        const key = info.kind + info.deviceId;\n        return <option key={key}>{info.label}</option>;\n      })}\n    </select>\n  );\n};\n\ntype MediaStreamType = [\n  MediaStreamAudioSourceNode | undefined,\n  AnalyserNode | undefined\n];\nfunction useMediaStream(audioCtx: AudioContext): MediaStreamType {\n  const [source, setSource] = useState<MediaStreamAudioSourceNode>();\n  const [analyzer, setAnalyzer] = useState<AnalyserNode>();\n\n  useEffect(() => {\n    navigator.mediaDevices\n      .getUserMedia({ audio: true })\n      .then(stream => {\n        const source = audioCtx.createMediaStreamSource(stream);\n        const analyzerNode = audioCtx.createAnalyser();\n        analyzerNode.fftSize = 256;\n        analyzerNode.smoothingTimeConstant = 0.85;\n        analyzerNode.minDecibels = -90;\n        analyzerNode.maxDecibels = -10;\n\n        const gainNode = audioCtx.createGain();\n        gainNode.gain.setValueAtTime(3, audioCtx.currentTime);\n\n        source.connect(gainNode);\n        gainNode.connect(analyzerNode);\n\n        setSource(source);\n        setAnalyzer(analyzerNode);\n      });\n  }, [audioCtx]);\n\n  return [source, analyzer];\n}\n\nconst AudioPage: React.SFC = props => {\n  const audioCtx = useMemo(() => new window.AudioContext(), []);\n  const [, analyzer] = useMediaStream(audioCtx);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const canvasCtx = useMemo(\n    () =>\n      canvasRef.current != null ? canvasRef.current.getContext(\"2d\") : null,\n    [canvasRef.current]\n  );\n\n  audioCtx.resume();\n  useEffect(() => {\n    if (canvasCtx === null) return;\n    if (analyzer === undefined) return;\n    if (canvasRef.current === null) return;\n\n    const canvas = canvasRef.current\n    const width = canvas.width\n    const height = canvas.height\n\n    const drawTimeData = (dataArray : Uint8Array, canvasCtx : CanvasRenderingContext2D) => {\n      canvasCtx.lineWidth = 2\n      canvasCtx.strokeStyle = \"rgba(255, 255, 0, 0.5)\"\n\n      canvasCtx.beginPath()\n      const sliceWidth = (width * 1.0) / dataArray.length\n      let x = 0\n      for (let i = 0; i < dataArray.length; i++, x += sliceWidth) {\n        let value = dataArray[i] / 128.0\n        let y = (value * height) / 2\n        if (i === 0) {\n          canvasCtx.moveTo(x, y)\n        } else {\n          canvasCtx.lineTo(x, y);\n        }\n      }\n      canvasCtx.lineTo(width, height / 2);\n      canvasCtx.stroke();\n    }\n\n    const draw = () => {\n      canvasCtx.clearRect(0, 0, width, height);\n      canvasCtx.fillStyle = \"rgb(200, 200, 200, 0.25)\";\n      canvasCtx.fillRect(0, 0, width, height);\n\n      let dataArray : Uint8Array;\n      if (true) {\n        analyzer.fftSize = 512\n\n        dataArray = new Uint8Array(analyzer.frequencyBinCount);\n        analyzer.getByteTimeDomainData(dataArray);\n        drawTimeData(dataArray, canvasCtx)\n\n        analyzer.getByteFrequencyData(dataArray);\n        const barWidth = (width / dataArray.length)\n        let x = 0\n        for (let i = 0; i < dataArray.length; i +=4, x += (barWidth*4+1)) {\n          let value = \n            (dataArray[i+0] + dataArray[i+1]  + dataArray[i+2]  + dataArray[i+3])/4.0\n          let y = value / 256 * height;\n\n          let a = 1\n          let h = i * 256*3/2 / dataArray.length;\n\n          canvasCtx.fillStyle = `hsla(${h}, 100%, 50%, ${a})`\n          canvasCtx.fillRect(x, height - y, barWidth*4, height)\n        }\n      }\n\n      requestAnimationFrame(draw);\n    };\n    draw();\n  }, [audioCtx, analyzer, canvasCtx, canvasRef]);\n\n  return (\n    <Fragment>\n        <canvas ref={canvasRef}  style={{display:'block', width:'90vw', height:'auto'}}></canvas>\n    </Fragment>\n  );\n};\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n      </header>\n      <div className=\"App-main\">\n        <PermissionSwitch permissionDescription={{ name: \"microphone\" }}>\n          <PermissionWhen state=\"granted\">\n            <div>Granted</div>\n            <AudioPage />\n          </PermissionWhen>\n          <PermissionWhen state=\"denied\">\n            <div>Denied</div>\n          </PermissionWhen>\n          <PermissionWhen state=\"prompt\">\n            <div>Prompt</div>\n            <AudioPage />\n          </PermissionWhen>\n        </PermissionSwitch>\n      </div>\n      <footer className=\"App-footer\">\n        {config.name} - {config.version}\n      </footer>\n    </div>\n  );\n};\n\nexport default App;\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n"],"sourceRoot":""}