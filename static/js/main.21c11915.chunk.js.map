{"version":3,"sources":["components/atoms/Permission.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["PermissionContext","React","createContext","state","name","PermissionSwitch","props","permission","permissionDescription","useState","setState","navigator","permissions","query","then","result","onchange","usePermissionState","Provider","value","children","PermissionWhen","useContext","AudioPage","audioCtx","useMemo","window","AudioContext","source","setSource","analyzer","setAnalyzer","useEffect","mediaDevices","getUserMedia","audio","stream","createMediaStreamSource","analyzerNode","createAnalyser","fftSize","smoothingTimeConstant","minDecibels","maxDecibels","gainNode","createGain","gain","setValueAtTime","currentTime","connect","useMediaStream","canvasRef","useRef","canvasCtx","current","getContext","resume","undefined","console","log","canvas","draw","dataArray","clearRect","width","height","fillStyle","fillRect","Uint8Array","frequencyBinCount","getByteTimeDomainData","lineWidth","strokeStyle","beginPath","sliceWidth","length","x","i","y","moveTo","lineTo","stroke","drawTimeData","getByteFrequencyData","barWidth","requestAnimationFrame","ref","App","className","config","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.21c11915.chunk.js","sourcesContent":["import { useState, Fragment, useContext } from \"react\"\nimport React from \"react\"\n\n/**\n * Checks given permission\n * @export\n * @param {PermissionDescriptor} permissionDescription\n * @returns {PermissionState}\n */\nexport function usePermissionState(permissionDescription: PermissionDescriptor): PermissionState {\n  const [state, setState] = useState<PermissionState>(() => \"denied\");\n  navigator.permissions.query(permissionDescription).then(result => {\n    setState(result.state);\n    result.onchange = () => setState(result.state);\n  });\n  return state;\n}\n\n\ninterface PermissionContextType {\n  state : PermissionState\n  name : PermissionName\n}\nconst permissionContext : PermissionContextType = {\n  state : 'denied',\n  name : 'microphone'\n}\nconst PermissionContext = React.createContext<PermissionContextType>(permissionContext)\ninterface PermissionSwitchProps {\n  permissionDescription : PermissionDescriptor\n}\nexport const PermissionSwitch: React.SFC<PermissionSwitchProps> = (props) => {\n  const permission = usePermissionState(props.permissionDescription)\n  return (\n    <PermissionContext.Provider value={{state:permission, name:props.permissionDescription.name}}>\n      {props.children}\n    </PermissionContext.Provider>\n  )\n}\n\ninterface PermissionWhenProps {\n  state : PermissionState\n}\nexport const PermissionWhen: React.SFC<PermissionWhenProps> = (props) => {\n  const permission = useContext(PermissionContext)\n  if (permission.state === props.state) {\n    return (<Fragment>{props.children}</Fragment>)\n  }\n  return (null)\n}\n","import React, {\n  useState,\n  useCallback,\n  useEffect,\n  ChangeEventHandler,\n  Fragment,\n  useMemo,\n  useRef\n} from \"react\";\nimport {\n  PermissionSwitch,\n  PermissionWhen\n} from \"./components/atoms/Permission\";\n\nimport logo from \"./logo.svg\";\nimport \"./App.css\";\n\nimport * as config from \"./../package.json\";\n\ntype MediaInfoFilter = (value: MediaDeviceInfo) => boolean;\n\nfunction useMediaDevices(\n  withRequestAccess: boolean,\n  deviceFilter?: MediaInfoFilter\n) {\n  const [devices, setDevices] = useState<MediaDeviceInfo[]>([]);\n\n  const enumerateDevices = useCallback(\n    () =>\n      navigator.mediaDevices\n        .enumerateDevices()\n        .then(devices =>\n          setDevices(deviceFilter ? devices.filter(deviceFilter) : devices)\n        ),\n    [deviceFilter]\n  );\n\n  useEffect(() => {\n    if (withRequestAccess) {\n      navigator.mediaDevices\n        .getUserMedia({ audio: true })\n        .then(stream => enumerateDevices());\n    } else {\n      enumerateDevices();\n    }\n  }, [withRequestAccess, enumerateDevices]);\n\n  return devices;\n}\n\ntype OnDeviceSelectedCallback = (\n  deviceInfo: MediaDeviceInfo | undefined\n) => void;\ninterface MediaDeviceSelectorProps {\n  onSelected: OnDeviceSelectedCallback;\n  constraints?: MediaStreamConstraints;\n}\nexport const MediaDeviceSelector: React.SFC<\n  MediaDeviceSelectorProps\n> = props => {\n  const defaultDeviceFilter = (t: MediaDeviceInfo) => t.kind === \"audioinput\";\n  const devices = useMediaDevices(true, defaultDeviceFilter);\n  const handleOnChange = useCallback<ChangeEventHandler<HTMLSelectElement>>(\n    event => {\n      event.preventDefault();\n      if (props.onSelected) {\n        props.onSelected(devices[event.target.selectedIndex]);\n      }\n    },\n    [devices, props]\n  );\n  return (\n    <select onChange={handleOnChange}>\n      {devices.map(info => {\n        const key = info.kind + info.deviceId;\n        return <option key={key}>{info.label}</option>;\n      })}\n    </select>\n  );\n};\n\ntype MediaStreamType = [\n  MediaStreamAudioSourceNode | undefined,\n  AnalyserNode | undefined\n];\nfunction useMediaStream(audioCtx: AudioContext): MediaStreamType {\n  const [source, setSource] = useState<MediaStreamAudioSourceNode>();\n  const [analyzer, setAnalyzer] = useState<AnalyserNode>();\n\n  useEffect(() => {\n    navigator.mediaDevices\n      .getUserMedia({ audio: true })\n      .then(stream => {\n        const source = audioCtx.createMediaStreamSource(stream);\n        const analyzerNode = audioCtx.createAnalyser();\n        analyzerNode.fftSize = 256;\n        analyzerNode.smoothingTimeConstant = 0.75;\n        analyzerNode.minDecibels = -90;\n        analyzerNode.maxDecibels = -10;\n\n        const gainNode = audioCtx.createGain();\n        gainNode.gain.setValueAtTime(3, audioCtx.currentTime);\n\n        source.connect(gainNode);\n        gainNode.connect(analyzerNode);\n\n        setSource(source);\n        setAnalyzer(analyzerNode);\n      });\n  }, [audioCtx]);\n\n  return [source, analyzer];\n}\n\nconst AudioPage: React.SFC = props => {\n  const audioCtx = useMemo(() => new window.AudioContext(), []);\n  const [, analyzer] = useMediaStream(audioCtx);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const canvasCtx = useMemo(\n    () =>\n      canvasRef.current != null ? canvasRef.current.getContext(\"2d\") : null,\n    [canvasRef.current]\n  );\n\n  audioCtx.resume();\n  useEffect(() => {\n    if (canvasCtx === null) return;\n    if (analyzer === undefined) return;\n    if (canvasRef.current === null) return;\n\n    console.log(\"analyzer\", analyzer);\n    console.log(\"Canvas\", canvasCtx);\n//    const dataArray = new Uint8Array(analyzer.frequencyBinCount);\n    const canvas = canvasRef.current;\n\n    const drawTimeData = (dataArray : Uint8Array, canvasCtx : CanvasRenderingContext2D) => {\n      canvasCtx.lineWidth = 2\n      canvasCtx.strokeStyle = \"rgb(255, 255, 0)\"\n\n      canvasCtx.beginPath()\n      const sliceWidth = (canvas.width * 1.0) / dataArray.length\n      let x = 0\n      for (let i = 0; i < dataArray.length; i++, x += sliceWidth) {\n        let value = dataArray[i] / 128.0\n        let y = (value * canvas.height) / 2\n        if (i === 0) {\n          canvasCtx.moveTo(x, y)\n        } else {\n          canvasCtx.lineTo(x, y);\n        }\n      }\n      canvasCtx.lineTo(canvas.width, canvas.height / 2);\n      canvasCtx.stroke();\n    }\n\n    const draw = () => {\n      canvasCtx.clearRect(0, 0, canvas.width, canvas.height);\n      canvasCtx.fillStyle = \"rgb(200, 200, 200)\";\n      canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\n\n      let dataArray : Uint8Array;\n      if (true) {\n        analyzer.fftSize = 1024\n        dataArray = new Uint8Array(analyzer.frequencyBinCount);\n        analyzer.getByteTimeDomainData(dataArray);\n        drawTimeData(dataArray, canvasCtx)\n\n        analyzer.fftSize = 1024\n        dataArray = new Uint8Array(analyzer.frequencyBinCount);\n        analyzer.getByteFrequencyData(dataArray);\n        const barWidth = (canvas.width / dataArray.length)\n        let x = 0\n        for (let i = 0; i < dataArray.length; i++, x += (barWidth+1)) {\n          let value = dataArray[i]\n\n          canvasCtx.fillStyle = `rgb(${value*3/2+50}, 50, 50)`\n          canvasCtx.fillRect(x, canvas.height-value, barWidth, canvas.height)\n        }\n      }\n\n      requestAnimationFrame(draw);\n    };\n    draw();\n  }, [audioCtx, analyzer, canvasCtx, canvasRef]);\n\n  return (\n    <Fragment>\n      <canvas ref={canvasRef} width=\"800\" height=\"600\"></canvas>\n    </Fragment>\n  );\n};\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      {/* <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n      </header> */}\n      <main className=\"App-main\">\n        <PermissionSwitch permissionDescription={{ name: \"microphone\" }}>\n          <PermissionWhen state=\"granted\">\n            <div>Granted</div>\n            <AudioPage />\n          </PermissionWhen>\n          <PermissionWhen state=\"denied\">\n            <div>Denied</div>\n          </PermissionWhen>\n          <PermissionWhen state=\"prompt\">\n            <div>Prompt</div>\n            <AudioPage />\n          </PermissionWhen>\n        </PermissionSwitch>\n      </main>\n      <footer className=\"App-footer\">\n        <div>\n          {config.name} - {config.version}\n        </div>\n      </footer>\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}